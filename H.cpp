#include <cstdint>
#include <cstdio>
#include <iostream>
#include <vector>

/*

# H. Темпоральный катаклизм

## Легенда
Доктор Кто заметил, что каждое решение, принятое человечеством, создает новую временную ветвь,
разделяя поток времени на бесчисленные альтернативные реальности. Эти ветви переплетаются в сложное
древо, где каждая развилка - это новый вариант будущего.

Однако недавний темпоральный катаклизм нарушил естественный ход времени, и теперь все эти ветви
начинают нестабильно взаимодействовать друг с другом, угрожая привести к разрушению временного
континуума. Чтобы предотвратить распад реальности, Доктору Кто необходимо перемещаться между
ключевыми временными точками и восстанавливать порядок.

Но есть одна загвоздка: заряд ТАРДИС - машины времени Доктора - ограничен, и каждый прыжок по
временным линиям требует определённого количества энергии. Доктор должен оценить, хватит ли заряда
для перемещения от одной точки к другой.

Помогите Доктору Кто справиться с последствиями темпорального катаклизма, путешествуя по ветвям
времени и восстанавливая баланс в альтернативных реальностях!

## Формат ввода
На вход подаётся следующее:

Первой строкой задаётся число N - количество временных точек (вершин) в древе, такое что 1 ≤ N ≤
10^5

Следующие N−1 строк описывают связи (рёбра) между временными точками. Каждая строка содержит два
числа u и v, которые обозначают соединение между временными точками u и v. Эти идентификаторы -
натуральные числа от 0 до N-1, уникальные для каждой временной точки.

После этого задаётся число Q - количество запросов на перемещение, такое что Q ≤ 10^6. Следующие Q
строк содержат описание запросов. Каждый запрос представлен тремя числами: два идентификатора
временных точек u и v, между которыми Доктор хочет переместиться, и величина заряда T, доступного
для этого перемещения, т.е. максимально возможное расстояние на которое можно переместиться,
измеряемое в числе пройденных ребер, данная величина не превосходит N.

## Формат вывода
На выходе для каждого запроса необходимо вывести одну строку:

"Yes", если Доктор может переместиться между двумя указанными временными точками при доступном
заряде T (то есть если расстояние между точками меньше либо равно T). "No", если заряд недостаточен
для совершения перемещения (то есть если расстояние больше T).

Каждый ответ выводится в отдельной строке, в том же порядке, в каком поступили запросы.

## Описание решения
Кажется, можно реализовать определенный предподсчет, чтобы отвечать на запросы за константное время.
Например, если заданный граф подвесить за какую-нибудь вершину, то количество ребер между двумя
любыми вершинами вычисляется по формуле: dist(A, B) = depth(A) + depth(B) - 2 depth(lca(A, B)). Где
dist - расстояние между вершинами, depth - глубина вершины, lca - наименьший общий предок вершин.
Действительно, расстояние между двумя вершинами A, B представляет из себя путь A -> lca(A, B) -> B.
Если знать глубину каждой из вершин, то можно легко рассчитать расстояние по указанной формуле.

Соответственно, для решения задачи необходимо подвесить граф за любую вершину (например за 0),
подсчитать глубину каждой вершины, а также уметь быстро находить наименьшего общего предка двух
вершин.

Для расчета глубин вершин воспользуемся BFS.

Для поиска предка будем использовать двоичный подъем. Для этого посчитаем массив значений up[v][k] -
предок вершины V через 2^K шагов (для 10^5 вершин достаточно рассчитать до K = 17). Что дает
подобная структура хранения? Позволяет за константное время находить любого предка заданной вершины.
Если необходимо найти родителя вершины V через 10 шагов (0b1010), то сначала берем вершину p1 =
up[v][3], для найденной вершины берем p2 = up[v][1]. Это и будет предок вершины V через 10 шагов
(согласно битовому представлению числа 10).

Как при помощи описанного поиска найти значение функции lca для вершин A, B? Первым делом нужно
выровнять вершины, то есть взять низшую из двух и найти ее родителя через количество шагов, равное
разности в высоте между заданными вершинами. Далее для двух заданных вершин необходимо взять
наиболее высоких известных предков (из матрицы up), которые отличаются. Повторив последний шаг
нужное количество раз мы найдем общего предка (максимум 17 итераций подъема). Иными словами,
максимально поднимаемся по предкам вершин наверх, пока не найдем общего.

## Асимптотика решения
Время: O(N * log2(N_max) + Q * log2(N_max))
Память: O(N * log2(N_max))

*/

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);

  int32_t N;
  std::cin >> N;

  std::vector<std::vector<int32_t>> g;
  g.resize(N);

  for (int32_t i = 0; i < N - 1; i++) {
    int32_t u, v;
    std::cin >> u >> v;
    g[u].push_back(v);
    g[v].push_back(u);
  }

  // --- LCA подготовка ---
  const int32_t LOG = 17;  // так как 2^17 > 1e5
  std::vector<std::vector<int32_t>> up(N, std::vector<int32_t>(LOG));
  std::vector<int32_t> depth(N);

  // DFS для depth[] и up[][0]
  std::vector<int32_t> stack;
  stack.reserve(N);
  stack.push_back(0);

  up[0][0] = 0;
  depth[0] = 0;

  std::vector<int32_t> parent(N, -1);
  parent[0] = 0;

  while (!stack.empty()) {
    int32_t v = stack.back();
    stack.pop_back();

    for (int32_t to : g[v]) {
      if (to == parent[v])
        continue;
      parent[to] = v;
      depth[to] = depth[v] + 1;
      up[to][0] = v;
      stack.push_back(to);
    }
  }

  // Заполняем таблицу подъёмов up[v][k]
  for (int32_t k = 1; k < LOG; k++) {
    for (int32_t v = 0; v < N; v++) {
      up[v][k] = up[up[v][k - 1]][k - 1];
    }
  }

  // Функция подъёма
  auto lift = [&](int32_t v, int32_t h) {
    for (int32_t k = 0; k < LOG; k++) {
      if (h & (1 << k)) {
        v = up[v][k];
      }
    }
    return v;
  };

  // LCA
  auto lca = [&](int32_t a, int32_t b) {
    if (depth[a] < depth[b]) {
      int32_t tmp = a;
      a = b;
      b = tmp;
    }

    a = lift(a, depth[a] - depth[b]);
    if (a == b)
      return a;

    for (int32_t k = LOG - 1; k >= 0; k--) {
      if (up[a][k] != up[b][k]) {
        a = up[a][k];
        b = up[b][k];
      }
    }
    return up[a][0];
  };

  // --- Обработка запросов ---
  int32_t Q;
  std::cin >> Q;

  std::string result;

  while (Q--) {
    int32_t u, v;
    int32_t T;
    std::cin >> u >> v >> T;

    int32_t c = lca(u, v);
    int32_t dist = depth[u] + depth[v] - 2 * depth[c];

    if (dist <= T) {
      result += "Yes\n";
    } else {
      result += "No\n";
    }
  }

  std::cout << result;

  return 0;
}
