#include <iostream>
#include <vector>

/*

# F. Праздничная лента

## Легенда
У вас есть лента, на которой написано n латинских букв. Буквы пронумерованы от 1 до n.

Также у вас есть текст, состоящий ровно из m слов.

Вы хотите выбрать и закрасить некоторое количество букв на ленте, чтобы получить текст, состоящий в
точности из заданных слов. Для того чтобы текст был читаемым и понятным, необходимо, чтобы после
закрашивания всех выбранных букв было выполнено следующее:
- между каждой парой слов была хотя бы одна закрашенная буква (при этом, наличие закрашенных букв
перед первым или после последнего слова текста не обязательно);
- в полученном тексте не было никаких других слов, кроме указанных;
- все слова текста должны следовать друг за другом в указанном порядке.

Для заданной строки s, описывающей ленту, и m слов, составляющих текст, вам необходимо определить,
можете ли вы закрашиванием некоторого количества букв получить текст, удовлетворяющий всем условиям
выше.

Например, если на ленте написаны следующие 17 букв: «HHHappyabNewQYear», и вы хотите получить текст,
состоящий из трех слов «Happy», «New» и «Year», то для выполнения всех вышеуказанных условий
достаточно закрасить буквы с индексами 1,2,8,9 и 13.

## Формат ввода
Первая строка входных данных содержит ровно два целых положительных числа n (1 ≤ n ≤ 10^5) и m (1 ≤
m ≤ 10^3) — количества букв на ленте и слов в тексте соответственно.

Вторая строка входных содержит строку s, состоящую из n латинских букв, которые могут быть как
строчными, так и заглавными.

Далее следуют m строк, каждая из которых содержит слово текста t_i (1 ≤ ∣t_i∣ ≤ 10^5). Каждое слово
t_i также состоит из латинских букв, которые могут быть как строчными, так и заглавными.

Гарантируется, что сумма длин всех строк t_i не превышает числа n.

## Формат вывода
Выведите:
- «YES», если можно выбрать и закрасить некоторое количество букв на ленте таким образом, чтобы
получился заданный текст из m слов и все условия, указанные в задаче, были выполнены;
- «NO» иначе.

Вы можете выводить ответ в любом регистре (например, строки «yEs», «yes», «Yes» и «YES» будут
распознаны как положительный ответ).

## Описание решения
Реализуем простое решение с использованием двух указателей. Первый указатель будет итерироваться по
праздничной ленте. Второй указатель будет итерироваться по словам из списка слов.

Если символ у обоих указателей совпадает, то двигаем их на +1. Если указатель по словам кончился, то
передвигаем его на первую букву нового слова при этом указатель по ленте двигаем дополнительно на +1
(между каждыми словами должна быть минимум одна буква).

Если слова кончились к концу ленты или в середине ленты, то завершаем цикл и выводим "YES". Иначе
"NO".

## Асимптотика решения
Время: O(n)
Память: O(n)

*/

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);

  int32_t n, m;
  std::cin >> n >> m;

  std::string s;
  std::cin >> s;

  std::vector<std::string> words(m);
  for (int i = 0; i < m; i++) {
    std::cin >> words[i];
  }

  size_t word_idx = 0;  // index of current word
  std::string& word = words[word_idx];
  size_t w_ptr = 0;  // pointer inside words[w]

  for (size_t s_ptr = 0; s_ptr < s.length(); s_ptr++) {
    if (s[s_ptr] == word[w_ptr]) {
      w_ptr++;

      if (w_ptr == word.length()) {
        word_idx++;

        if (word_idx == words.size()) {
          break;
        }

        word = words[word_idx];
        w_ptr = 0;

        s_ptr++;
      }
    }
  }

  if (word_idx == words.size() && w_ptr == words[words.size() - 1].length()) {
    std::cout << "YES";
  } else {
    std::cout << "NO";
  }

  return 0;
}
