#pragma once

#include <cassert>
#include <cstddef>
#include <cstdint>
#include <cstdlib>
#include <vector>

/*

# B. Количество единиц в двоичной записи

## Легенда
В мобильном клиенте интернет-магазина "Тындекс.Экспресс" необходимо реализовать ленту лучших
товаров. Лента представляет собой бесконечный список карточек товаров, который можно прокручивать.
На каждой карточке представлена информация о товаре.

С каждым товаром связан уникальный идентификатор, а еще его рейтинг. Уникальный идентификатор -
положительное целое число (SERIAL из PostgreSQL), рейтинг - положительное целое число длины 16 бит
(такое значение им приходит от какой-то модели).

В списке товары отсортированы по возрастанию рейтинга, а если рейтинг совпадает, то выше будет товар
с наименьшим идентификатором. Получается, что тем меньше рейтинг, тем выше (лучше) товар в списке.
Пользователь должен иметь возможность быстро находить в списке товар по идентификатору или
порядковому номеру в ленте лучших товаров. То есть при заполнении некоторой формы, осуществляется
переход на нужную карточку в списке.

Конечно же, товаров в системе может быть достаточно много, потому загружать информацию о всех
товарах в оперативную память устройства может быть не очень удобно, поэтому пришлось реализовать
некоторый аналог пагинации, только для бесконечно прокручивающихся списков.

Кроме этого, множество товаров на маркетплейсе "Тындекс.Экспресс" постоянно изменяется - там
постоянно появляются новые, исчезают старые товары, а также меняется рейтинг товаров.

Инженеры из команды мобильной разработки сообщили, что им для реализации обсуждаемой
функциональности будет достаточно API метода, возвращающего список товаров заданной длины,
начинающийся с товара с заданным идентификатором или позицией в топе.

Естественно, хотим, чтобы все работало быстро - как методы получения, так и методы обновления
данных. Ожидаемая нагрузка: редкие удаления, добавления, частые обновления, очень частые запросы на
получение. Однако, нужно быть готовым к атакам с иным паттерном нагрузки.

Наши тестировщики уже разработали модульные тесты для нашего нового компонента. Осталось лишь вам
реализовать интерфейс! Подразумевается, что входные данные корректны.

## Формат ввода
Первая строка входных данных содержит целое число n (0 ≤ n ≤ 1000000) — количество операций.
Следующие n строк описывают операции.

Строки имеют вид:
- i <id> <score>. Добавление товара с уникальным идентификатором id и рейтингом score.
Гарантируется, уникальность идентификатора, а также 1 ≤ id ≤ 10000000, 1 ≤ score ≤ 65535.
- u <id> <score>. Обновление товара. Гарантируется, что товар с заданным идентификатором был
добавлен в коллекцию.
- r <id>. Удаление товара. Гарантируется, что товар с заданным идентификатором был добавлен в
коллекцию и после удаления больше никогда не появится.
- p <position> <limit>. Получение limit товаров, начиная с позиции в ленте position. Гарантируется,
что 0 ≤ position < length(feed), 1 ≤ limit ≤ 16.
- g <id> <limit>. Получение limit товаров, начиная с товара, имеющего уникальный идентификатор id.
Гарантируется, что товар есть в коллекции.

## Формат вывода
Сперва в отдельной строке выведите Started.

Далее для каждой из n операций в отдельной строке выведите:
- Added после добавления.
- Updated после обновления.
- Removed после удаления.
- AtPos: [(item_id ',' ' ')+] после получения товаров по позиции в списке.
- AtId: [(item_id ',' ' ' )+] после получения товаров по идентификатору товара.

## Описание решения
TBD

## Асимптотика решения
Время: TBD
Память: TBD

*/

namespace youndex::express {

struct Item {
  std::uint64_t id;
  std::uint16_t score;
};

/// NB: Is not thread safe.
class ItemFeed final {
public:
  [[nodiscard]] std::vector<std::uint64_t> GetAtPosition(
      std::size_t position, std::size_t limit
  ) const {
    assert(position < Size());
    assert(1 <= limit && limit <= 16);

    (void)position;
    (void)limit;

    std::abort();  // Not implemented
  }

  [[nodiscard]] std::vector<std::uint64_t> GetAtItemWithId(
      std::uint64_t uid, std::size_t limit
  ) const {
    assert(Contains(uid));
    assert(1 <= limit && limit <= 16);

    (void)uid;
    (void)limit;

    std::abort();  // Not implemented
  }

  void Add(Item item) {
    assert(!Contains(item.id));

    (void)item;

    std::abort();  // Not implemented
  }

  void Update(Item item) {
    assert(Contains(item.id));

    (void)item;

    std::abort();  // Not implemented
  }

  void Remove(std::uint64_t uid) {
    assert(Contains(uid));

    (void)uid;

    std::abort();  // Not implemented
  }

private:
  [[nodiscard]] bool Contains(std::uint64_t uid) const {
    assert(1 <= uid);

    (void)uid;

    std::abort();  // Not implemented
  }

  [[nodiscard]] std::size_t Size() const {
    std::abort();  // Not implemented
  }
};

}  // namespace youndex::express
