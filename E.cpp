#include <array>
#include <deque>
#include <iostream>
#include <vector>

/*

# E. Фарид и ХOR такси

## Легенда
В ИТМО все знают про Фарида и его девушку. Он решил пойти с ней на свидание, но есть одна проблема —
у него осталось мало денег.

Представим Санкт-Петербург в виде дерева из n узлов, где каждый узел обозначает место, а между
некоторыми парами мест есть n - 1 двунаправленных дорог, так что существует уникальный путь между
любой парой мест.

У девушки Фарида есть странная особенность — ей нравятся цветы только из одного конкретного
цветочного магазина, который находится в месте с номером f.

Недавно компания Тындекс запустила специальные машины, называемые "xor-cars". Особенность этих машин
в том, что они предоставляют скидку, равную XOR-сумме весов дорог, по которым проходит маршрут.
Иными словами, если вы едете из места x в место y по дорогам с длинами w_0, w_1, w_2...w_n, то вы
получите скидку, равную (w_0 xor w_1 xor w_2 xor...xor w_n).

Фарид, будучи жадным, хочет узнать, какую максимальную скидку он может получить, если ему разрешено
выбирать места, где он живет (x) и где живет его девушка (y), при этом соблюдаются следующие
условия: x != y, x != f, y != f. Кроме того, ему нужно заехать в цветочный магазин в месте f, то
есть сначала он берет Тындекс xor-car из места x и едет в место f, а затем из места f — в место y,
где его ждет девушка.

Помогите Фариду найти максимальную скидку за такую поездку.

## Формат ввода
Первая строка содержит два целых числа, разделенных пробелом, n и f, где n — это количество мест в
Санкт-Петербурге, а f — номер места, где находится цветочный магазин.

Следующие n−1 строк содержат по три целых числа u[i], v[i] и w[i], которые обозначают, что между
местом u[i] и местом v[i] существует двунаправленная дорога длиной w[i].

3 <= n <= 200,000
1 <= f <= n
1 <= u[i], v[i] <= n, (u[i] != v[i])
1 <= w[i] <= 1,000,000,000

## Формат вывода
Выведите одно целое число, максимальную скидку, которую может получить Фарид, если у него есть
возможность выбрать места, в которых будут жить он и его девушка, и он поедет туда на машине Тындекс
с функцией xor. (Не забудьте взять цветы :)) )

## Описание решения
По сути нужно найти две таких вершины x, y такие, что путь x -> f -> y дает наибольшее значение
xor-расстояния. Если предположить, что мы знаем xor-расстояния от вершины f до всех остальных, то
задача сводится к тому, чтобы найти два таких числа, которые дадут наибольшее xor-значение.

Получается задачу можно разбить на два этапа: 1 - посчитать xor-расстояния от вершины f до всех
остальных; 2 - найти пару значений, дающих наибольшее xor-значение.

Первый этап будем решать обходом графа в ширину от вершины f. Поскольку путь до каждой вершины
единственный и уникальный, то для каждой пройденной вершины запомним одно число - xor между
значениями длин дорог от вершины f до текущей вершины. При итерации по соседям для определенной
вершины, посчитаем описанное значение (если оно уже не посчитано) и запомним его. Для вершины f это
значение примем равным 0.

Второй этап будем решать при помощи префиксного дерева (trie). Каждая вершина будет представлять
один из порядковых битов числа (1 или 0) и иметь максимум два ребенка. Чтобы покрыть все значения
расстояний до 1 млрд, достаточно будет 30 бит числа, то есть глубина построенного дерева будет
равна 30. Добавим в это дерево все найденные xor-расстояния. Далее для каждого из расстояний
попробуем по этому дереву найти число, дающее наибольшее значение xor с выбранным.

Поиск будем осуществлять следующим образом: берем соответствующий порядковый бит выбранного числа.
Чтобы получить наибольшее xor-значение нужно, чтобы существовало число, имеющее на месте этого бита
противоположное значение. Значит в соответствующей вершине префиксного дерева нужно пойти и
проверить, существует ли ребенок, соответствующий этому биту. Если существует, то переходим в него и
берем следующий бит. Не сложно убедиться, что при такой логике итерации, мы найдем число, дающее
максимальное xor-значение с выбранным. Остается только получить это xor-значение и найти
максимальное среди всех.

## Асимптотика решения
Время: O(n)
Память: O(n)

*/

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);

  int32_t n, f;
  std::cin >> n >> f;

  // adjacency list
  std::vector<std::vector<std::pair<int32_t, int32_t>>> adj(n + 1);

  for (int32_t i = 0; i < n - 1; ++i) {
    int32_t u, v, w;
    std::cin >> u >> v >> w;
    adj[u].push_back({v, w});
    adj[v].push_back({u, w});
  }

  // BFS to compute XOR distances from f
  std::vector<int32_t> val(n + 1, 0);
  std::vector<bool> used(n + 1, false);
  std::deque<int32_t> dq;

  dq.push_back(f);
  used[f] = true;

  while (!dq.empty()) {
    int32_t u = dq.front();
    dq.pop_front();

    for (const auto& e : adj[u]) {
      int32_t v = e.first;
      int32_t w = e.second;
      if (!used[v]) {
        used[v] = true;
        val[v] = val[u] ^ w;
        dq.push_back(v);
      }
    }
  }

  // Collect all XOR-values except node f
  std::vector<int32_t> A;
  A.reserve(static_cast<size_t>(n - 1));
  for (int32_t v = 1; v <= n; ++v) {
    if (v == f) {
      continue;
    }
    A.push_back(val[v]);
  }

  // Bitwise trie for max xor pair
  constexpr int32_t MAXB = 30;

  std::vector<std::array<int32_t, 2>> trie;
  trie.push_back({-1, -1});  // root

  auto trie_insert = [&](int32_t x) {
    int32_t node = 0;
    for (int32_t b = MAXB; b >= 0; --b) {
      int32_t bit = (x >> b) & 1;
      if (trie[node][bit] == -1) {
        trie[node][bit] = static_cast<int32_t>(trie.size());
        trie.push_back({-1, -1});
      }
      node = trie[node][bit];
    }
  };

  auto trie_max_xor_with = [&](int32_t x) -> int32_t {
    int32_t node = 0;
    int32_t res = 0;
    for (int32_t b = MAXB; b >= 0; --b) {
      int32_t bit = (x >> b) & 1;
      int32_t want = bit ^ 1;
      if (trie[node][want] != -1) {
        res |= (1 << b);
        node = trie[node][want];
      } else {
        node = trie[node][bit];
      }
    }
    return res;
  };

  // Insert all values
  for (int32_t x : A) {
    trie_insert(x);
  }

  // Compute answer
  int32_t answer = 0;
  for (int32_t x : A) {
    int32_t cur = trie_max_xor_with(x);
    if (cur > answer) {
      answer = cur;
    }
  }

  std::cout << answer << "\n";
  return 0;
}
